// SpacetimeDB Codegen
//
// Generates Zig source code from a SpacetimeDB schema. Given a parsed Schema,
// produces source text containing:
//   - A struct for each table with typed fields
//   - BSATN decode/encode via the comptime table layer
//   - Typed reducer call functions that auto-encode args
//
// Usage:
//   const schema = try schema_mod.parse(arena, json);
//   const source = try codegen.generate(arena, schema);
//   // write `source` to a .zig file

const std = @import("std");
const schema_mod = @import("schema.zig");
const types = @import("types.zig");

const Schema = schema_mod.Schema;
const TableDef = schema_mod.TableDef;
const ReducerDef = schema_mod.ReducerDef;
const AlgebraicType = types.AlgebraicType;
const Column = types.Column;

pub const CodegenError = std.mem.Allocator.Error || error{UnsupportedType};

/// Generate a complete Zig source file from a schema.
pub fn generate(allocator: std.mem.Allocator, schema: Schema) CodegenError![]const u8 {
    var buf = std.ArrayListUnmanaged(u8){};
    errdefer buf.deinit(allocator);
    const w = buf.writer(allocator);

    // File header
    try w.writeAll(
        \\// Auto-generated by SpacetimeDB Zig SDK codegen.
        \\// Do not edit manually — regenerate from schema.
        \\
        \\const std = @import("std");
        \\const stdb = @import("spacetimedb");
        \\
        \\
    );

    // Table structs
    for (schema.tables) |table| {
        try generateTableStruct(allocator, w, table);
        try w.writeAll("\n");
    }

    // Reducers namespace
    if (schema.reducers.len > 0) {
        try generateReducers(allocator, w, schema.reducers);
    }

    return buf.toOwnedSlice(allocator);
}

/// Generate a single table struct definition.
fn generateTableStruct(
    allocator: std.mem.Allocator,
    w: anytype,
    table: TableDef,
) CodegenError!void {
    const struct_name = try toPascalCase(allocator, table.name);
    defer allocator.free(struct_name);

    try w.print("pub const {s} = struct {{\n", .{struct_name});

    // Fields
    for (table.columns) |col| {
        const field_name = col.name orelse continue;
        const zig_type = try algebraicTypeToZig(allocator, col.type);
        defer allocator.free(zig_type);
        try w.print("    {s}: {s},\n", .{ field_name, zig_type });
    }

    try w.writeAll("\n");

    // decode from BSATN
    try w.print(
        \\    pub fn decode(alloc: std.mem.Allocator, data: []const u8) !{s} {{
        \\        return stdb.table.decodeRow({s}, alloc, data);
        \\    }}
        \\
    , .{ struct_name, struct_name });

    try w.writeAll("\n");

    // encode to BSATN
    try w.print(
        \\    pub fn encode(self: {s}, alloc: std.mem.Allocator) ![]u8 {{
        \\        return stdb.table.encodeRow({s}, alloc, self);
        \\    }}
        \\
    , .{ struct_name, struct_name });

    try w.writeAll("\n");

    // free
    try w.print(
        \\    pub fn free(self: *{s}, alloc: std.mem.Allocator) void {{
        \\        stdb.table.freeTypedRow({s}, alloc, self);
        \\    }}
        \\
    , .{ struct_name, struct_name });

    try w.writeAll("};\n");
}

/// Generate the Reducers namespace with typed call functions.
fn generateReducers(
    allocator: std.mem.Allocator,
    w: anytype,
    reducers: []const ReducerDef,
) CodegenError!void {
    try w.writeAll("pub const Reducers = struct {\n");
    try w.writeAll("    client: *stdb.client.SpacetimeClient,\n\n");

    try w.writeAll(
        \\    pub fn init(c: *stdb.client.SpacetimeClient) Reducers {
        \\        return .{ .client = c };
        \\    }
        \\
        \\
    );

    for (reducers) |reducer| {
        try generateReducerFn(allocator, w, reducer);
        try w.writeAll("\n");
    }

    try w.writeAll("};\n");
}

/// Generate a single reducer call function.
fn generateReducerFn(
    allocator: std.mem.Allocator,
    w: anytype,
    reducer: ReducerDef,
) CodegenError!void {
    const func_name = try toSnakeCase(allocator, reducer.name);
    defer allocator.free(func_name);

    if (reducer.params.len == 0) {
        // No-arg reducer
        try w.print(
            \\    pub fn {s}(self: *Reducers) !u32 {{
            \\        return self.client.callReducerRaw("{s}", "");
            \\    }}
            \\
        , .{ func_name, reducer.name });
    } else {
        // Reducer with params — generate arg struct and encode
        const arg_struct_name = try toPascalCase(allocator, reducer.name);
        defer allocator.free(arg_struct_name);

        // Function signature
        try w.print("    pub fn {s}(self: *Reducers, ", .{func_name});
        for (reducer.params, 0..) |param, i| {
            const param_name = param.name orelse "arg";
            const zig_type = try algebraicTypeToZig(allocator, param.type);
            defer allocator.free(zig_type);
            if (i > 0) try w.writeAll(", ");
            try w.print("{s}: {s}", .{ param_name, zig_type });
        }
        try w.writeAll(") !u32 {\n");

        // Build the args struct inline and encode
        try w.print("        const Args = struct {{ ", .{});
        for (reducer.params) |param| {
            const param_name = param.name orelse "arg";
            const zig_type = try algebraicTypeToZig(allocator, param.type);
            defer allocator.free(zig_type);
            try w.print("{s}: {s}, ", .{ param_name, zig_type });
        }
        try w.writeAll("};\n");

        try w.writeAll("        const args = Args{ ");
        for (reducer.params) |param| {
            const param_name = param.name orelse "arg";
            try w.print(".{s} = {s}, ", .{ param_name, param_name });
        }
        try w.writeAll("};\n");

        try w.writeAll(
            \\        const encoded = try stdb.table.encodeRow(Args, self.client.allocator, args);
            \\        defer self.client.allocator.free(encoded);
            \\        return self.client.callReducerRaw("
        );
        try w.writeAll(reducer.name);
        try w.writeAll(
            \\", encoded);
            \\    }
            \\
        );
    }
}

// ============================================================
// Type mapping
// ============================================================

/// Map an AlgebraicType to its Zig type string.
fn algebraicTypeToZig(allocator: std.mem.Allocator, typ: AlgebraicType) CodegenError![]const u8 {
    return switch (typ) {
        .bool => try allocator.dupe(u8, "bool"),
        .u8 => try allocator.dupe(u8, "u8"),
        .i8 => try allocator.dupe(u8, "i8"),
        .u16 => try allocator.dupe(u8, "u16"),
        .i16 => try allocator.dupe(u8, "i16"),
        .u32 => try allocator.dupe(u8, "u32"),
        .i32 => try allocator.dupe(u8, "i32"),
        .u64 => try allocator.dupe(u8, "u64"),
        .i64 => try allocator.dupe(u8, "i64"),
        .u128 => try allocator.dupe(u8, "u128"),
        .i128 => try allocator.dupe(u8, "i128"),
        .u256 => try allocator.dupe(u8, "[32]u8"),
        .i256 => try allocator.dupe(u8, "[32]u8"),
        .f32 => try allocator.dupe(u8, "f32"),
        .f64 => try allocator.dupe(u8, "f64"),
        .string => try allocator.dupe(u8, "[]const u8"),
        .bytes => try allocator.dupe(u8, "[]const u8"),
        .array => |inner| {
            const inner_zig = try algebraicTypeToZig(allocator, inner.*);
            defer allocator.free(inner_zig);
            return try std.fmt.allocPrint(allocator, "[]const {s}", .{inner_zig});
        },
        .option => |inner| {
            const inner_zig = try algebraicTypeToZig(allocator, inner.*);
            defer allocator.free(inner_zig);
            return try std.fmt.allocPrint(allocator, "?{s}", .{inner_zig});
        },
        .product => try allocator.dupe(u8, "stdb.row_decoder.Row"),
        .sum => try allocator.dupe(u8, "stdb.row_decoder.Row"),
        .ref => try allocator.dupe(u8, "stdb.row_decoder.Row"),
    };
}

// ============================================================
// Naming helpers
// ============================================================

/// Convert snake_case to PascalCase. Caller owns returned slice.
fn toPascalCase(allocator: std.mem.Allocator, name: []const u8) std.mem.Allocator.Error![]u8 {
    var result = std.ArrayListUnmanaged(u8){};
    errdefer result.deinit(allocator);

    var capitalize_next = true;
    for (name) |c| {
        if (c == '_' or c == '-' or c == ' ') {
            capitalize_next = true;
        } else if (capitalize_next) {
            try result.append(allocator, std.ascii.toUpper(c));
            capitalize_next = false;
        } else {
            try result.append(allocator, c);
        }
    }

    return result.toOwnedSlice(allocator);
}

/// Convert PascalCase/camelCase to snake_case. Caller owns returned slice.
fn toSnakeCase(allocator: std.mem.Allocator, name: []const u8) std.mem.Allocator.Error![]u8 {
    var result = std.ArrayListUnmanaged(u8){};
    errdefer result.deinit(allocator);

    for (name, 0..) |c, i| {
        if (std.ascii.isUpper(c)) {
            if (i > 0) try result.append(allocator, '_');
            try result.append(allocator, std.ascii.toLower(c));
        } else if (c == '-' or c == ' ') {
            try result.append(allocator, '_');
        } else {
            try result.append(allocator, c);
        }
    }

    return result.toOwnedSlice(allocator);
}

// ============================================================
// Tests
// ============================================================

test "generate from person schema" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    defer arena.deinit();
    const alloc = arena.allocator();

    const columns = [_]Column{
        .{ .name = "id", .type = .u64 },
        .{ .name = "name", .type = .string },
        .{ .name = "age", .type = .u32 },
    };
    const tables = [_]TableDef{.{
        .name = "person",
        .columns = &columns,
        .primary_key = &[_]u32{0},
    }};
    const reducer_params = [_]Column{
        .{ .name = "name", .type = .string },
        .{ .name = "age", .type = .u32 },
    };
    const reducers = [_]ReducerDef{
        .{ .name = "add_person", .params = &reducer_params },
        .{ .name = "say_hello", .params = &[_]Column{} },
    };
    const schema = Schema{
        .tables = &tables,
        .reducers = &reducers,
        .typespace = &.{},
        .allocator = alloc,
    };

    const source = try generate(alloc, schema);

    // Verify struct is generated
    try std.testing.expect(std.mem.indexOf(u8, source, "pub const Person = struct {") != null);
    try std.testing.expect(std.mem.indexOf(u8, source, "id: u64,") != null);
    try std.testing.expect(std.mem.indexOf(u8, source, "name: []const u8,") != null);
    try std.testing.expect(std.mem.indexOf(u8, source, "age: u32,") != null);

    // Verify decode/encode methods
    try std.testing.expect(std.mem.indexOf(u8, source, "pub fn decode(") != null);
    try std.testing.expect(std.mem.indexOf(u8, source, "pub fn encode(") != null);
    try std.testing.expect(std.mem.indexOf(u8, source, "pub fn free(") != null);

    // Verify reducer functions
    try std.testing.expect(std.mem.indexOf(u8, source, "pub const Reducers = struct {") != null);
    try std.testing.expect(std.mem.indexOf(u8, source, "pub fn add_person(") != null);
    try std.testing.expect(std.mem.indexOf(u8, source, "pub fn say_hello(") != null);

    // Verify no-arg reducer is simpler
    try std.testing.expect(std.mem.indexOf(u8, source, "callReducerRaw(\"say_hello\", \"\")") != null);
}

test "generate with option and array types" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    defer arena.deinit();
    const alloc = arena.allocator();

    const inner_u32: AlgebraicType = .u32;
    const inner_string: AlgebraicType = .string;
    const columns = [_]Column{
        .{ .name = "id", .type = .u64 },
        .{ .name = "email", .type = .{ .option = &inner_string } },
        .{ .name = "scores", .type = .{ .array = &inner_u32 } },
    };
    const tables = [_]TableDef{.{
        .name = "player",
        .columns = &columns,
        .primary_key = &[_]u32{0},
    }};
    const schema = Schema{
        .tables = &tables,
        .reducers = &[_]ReducerDef{},
        .typespace = &.{},
        .allocator = alloc,
    };

    const source = try generate(alloc, schema);

    try std.testing.expect(std.mem.indexOf(u8, source, "pub const Player = struct {") != null);
    try std.testing.expect(std.mem.indexOf(u8, source, "email: ?[]const u8,") != null);
    try std.testing.expect(std.mem.indexOf(u8, source, "scores: []const u32,") != null);
}

test "toPascalCase" {
    const alloc = std.testing.allocator;

    const r1 = try toPascalCase(alloc, "hello_world");
    defer alloc.free(r1);
    try std.testing.expectEqualStrings("HelloWorld", r1);

    const r2 = try toPascalCase(alloc, "person");
    defer alloc.free(r2);
    try std.testing.expectEqualStrings("Person", r2);

    const r3 = try toPascalCase(alloc, "my_cool_table");
    defer alloc.free(r3);
    try std.testing.expectEqualStrings("MyCoolTable", r3);
}

test "toSnakeCase" {
    const alloc = std.testing.allocator;

    const r1 = try toSnakeCase(alloc, "addPerson");
    defer alloc.free(r1);
    try std.testing.expectEqualStrings("add_person", r1);

    const r2 = try toSnakeCase(alloc, "say_hello");
    defer alloc.free(r2);
    try std.testing.expectEqualStrings("say_hello", r2);
}

test "generate from parsed JSON schema" {
    var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    defer arena.deinit();
    const alloc = arena.allocator();

    const json =
        \\{
        \\  "typespace": {
        \\    "types": [
        \\      {
        \\        "Product": {
        \\          "elements": [
        \\            {"name": {"some": "id"}, "algebraic_type": {"U64": []}},
        \\            {"name": {"some": "name"}, "algebraic_type": {"String": []}},
        \\            {"name": {"some": "age"}, "algebraic_type": {"U32": []}}
        \\          ]
        \\        }
        \\      }
        \\    ]
        \\  },
        \\  "tables": [
        \\    {
        \\      "name": "person",
        \\      "product_type_ref": 0,
        \\      "primary_key": [0]
        \\    }
        \\  ],
        \\  "reducers": [
        \\    {
        \\      "name": "add_person",
        \\      "params": {
        \\        "elements": [
        \\          {"name": {"some": "name"}, "algebraic_type": {"String": []}},
        \\          {"name": {"some": "age"}, "algebraic_type": {"U32": []}}
        \\        ]
        \\      }
        \\    }
        \\  ]
        \\}
    ;

    const schema = try schema_mod.parse(alloc, json);
    const source = try generate(alloc, schema);

    // Full pipeline: JSON → Schema → Zig source
    try std.testing.expect(std.mem.indexOf(u8, source, "pub const Person = struct {") != null);
    try std.testing.expect(std.mem.indexOf(u8, source, "pub fn add_person(") != null);
    try std.testing.expect(std.mem.indexOf(u8, source, "name: []const u8") != null);
}
